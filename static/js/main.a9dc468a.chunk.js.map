{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["App","props","formatTime","string","parseInt","min","second","toString","getSongsDuration","tempData","state","musicData","tracks","forEach","track","index","audio","Audio","file","duration","setState","getData","musicDataJSON","audios","sketch","p","fft","spectrum","waveform","preload","push","loadSound","setup","fileIsLoaded","createCanvas","windowWidth","parent","p5","FFT","frameRate","draw","angleMode","DEGREES","background","analyze","translate","canvasSize","width","height","beginShape","length","vertex","visRadius","value","angle","map","waveformMultiplier","minimum","valueCopy","cosVal","cos","sinVal","sin","endShape","toggleAudio","activeTrack","isPlaying","pause","loop","playlistSwitch","activeScreen","visualizer","currentMusicTime","direction","canChangePrevious","this","canChangeNext","prevState","console","log","jump","stop","play","interval","setInterval","currentTime","clearInterval","backgroundImageStyle","barWidth","renderedPlaylist","cover","key","className","artistName","title","style","id","album","onClick","changeSong","Component","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.a9dc468a.chunk.js","sourcesContent":["import React, {Component} from 'react'\nimport p5 from 'p5'\nimport 'p5/lib/addons/p5.sound';\nimport * as Vibrant from 'node-vibrant'\n\nimport musicDataJSON from './musicData.json'\n\nimport './App.css';\nimport { wrap } from 'module';\n\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { \n      visualizer : \"\",\n      visRadius : 100,\n      musicData : \"\",\n      canvasSize : {\n        width : 500,\n        height : 500\n      },\n      fileIsLoaded : false,\n      activeTrack :  0,\n      activeScreen : \"nowPlaying\",\n      currentMusicTime : 0,\n     }\n  }\n\n\n  formatTime = string => {\n    string = parseInt(string)\n    let min = (parseInt(string / 60))\n    min = min < 10 ? \"0\" + min.toString() : min.toString()\n    let second = string - min*60\n    second = second < 10 ? \"0\" + second.toString() : second.toString()\n    return min + \":\"+ second\n  }\n\n  getSongsDuration = () => {\n    let tempData = this.state.musicData\n    this.state.musicData.tracks.forEach((track, index) => {\n      let audio = new Audio(tempData.tracks[index].file)\n      tempData.tracks[index].duration = audio.duration\n    })\n    this.setState({ musicData: tempData });\n  }\n\n  getData =() => {\n    // wanted to do an api call but couldn't find an api that'd give me audio files...\n    this.setState({ musicData : musicDataJSON });\n  }\n\n  audios = []\n  sketch = p => {\n    let fft\n    let spectrum\n    let waveform\n\n    p.preload = () => {\n      this.state.musicData.tracks.forEach(track => {\n        this.audios.push(p.loadSound(track.file))\n      })\n    }\n\n    p.setup = () => {\n      this.setState({ fileIsLoaded: true })\n      p.createCanvas(p.windowWidth / 5, p.windowWidth / 5).parent('visualizer')\n      // this.audios[this.state.activeTrack].loop()\n      fft = new p5.FFT(0.9, 256)\n      p.frameRate(60)\n    }\n\n    p.draw = () => {\n      p.angleMode(p.DEGREES)\n      p.background(255)\n      // noStroke()\n      spectrum = fft.analyze()\n      waveform = fft.waveform()\n      p.translate(this.state.canvasSize.width / 2, this.state.canvasSize.height / 2);\n      p.beginShape()\n      if (spectrum[spectrum.length - 1] === 0) p.vertex(this.state.visRadius, 0)\n      spectrum.forEach((value, index) => {\n        let angle = p.map(index, 0, spectrum.length, 0, 361)\n        let waveformMultiplier = p.map(waveform[index], -1, 1, 1, 1.05)\n        let minimum = this.state.visRadius * waveformMultiplier\n        let valueCopy = p.map(value, 0, 255, minimum, 270)\n        let cosVal = valueCopy * p.cos(angle)\n        let sinVal = valueCopy * p.sin(angle)\n        p.vertex(cosVal, sinVal)\n        // line(0, 0, cosVal, sinVal)\n      })\n      p.endShape()\n    }\n  }\n\n  toggleAudio = () => {\n    this.state.fileIsLoaded & this.audios[this.state.activeTrack].isPlaying() ? this.audios[this.state.activeTrack].pause() : this.audios[this.state.activeTrack].loop()\n  }\n\n  changeSong(direction){\n    let canChangePrevious = direction === \"previous\" && this.state.activeTrack >= 1\n    let canChangeNext = direction === \"next\" && this.state.activeTrack < this.state.musicData.tracks.length - 1\n    this.setState(prevState => {\n      if (canChangePrevious) {\n        return { activeTrack: prevState.activeTrack-1 };\n      } else if (this.state.musicData) {\n        if (canChangeNext) {\n          console.log(\" ??? \");    \n          return { activeTrack: prevState.activeTrack+1 };\n        }\n      }\n    })\n\n    // c'est ghetto mais jsp pas pourquoi il y a un dÃ©lai sur la modif de state au dessus\n    if (canChangeNext || canChangePrevious) {\n      console.log(\"?\")\n      this.audios.forEach((audio, index) => {\n        if (canChangeNext) {\n          if (index !== this.state.activeTrack+1) {\n            audio.jump(0)\n            audio.stop()\n          } else {\n            audio.jump(0)\n            audio.play()\n          }\n        }\n        if (canChangePrevious) {\n          if (index !== this.state.activeTrack-1) {\n            audio.jump(0)\n            audio.stop()\n          } else {\n            audio.jump(0)\n            audio.play()\n          }\n        }\n      })\n    }\n  }\n  \n\n  interval\n  componentDidMount() {\n    this.setState({ visualizer: new p5(this.sketch) });\n    this.getData()\n\n    this.interval = setInterval(() => {\n      if (this.audios[this.state.activeTrack] && this.audios[this.state.activeTrack].isPlaying()) { \n        this.setState({ currentMusicTime: parseInt(this.audios[this.state.activeTrack].currentTime()) });\n      }\n    }, 1000);    \n\n    // this.getSongsDuration() // need to get all audio files first for this fn to work\n  }\n\n  componentWillUnmount(){\n    clearInterval(this.interval)\n  }\n\n\n  playlistSwitch = () => {\n    if (this.state.activeScreen === \"nowPlaying\") {\n      this.setState({ activeScreen: \"playlist\" });\n    } else {\n      this.setState({ activeScreen: \"nowPlaying\" });\n    }\n  }\n\n\n  render() { \n    let backgroundImageStyle\n    let barWidth\n    if (this.state.musicData.tracks) {\n      backgroundImageStyle = {\n        'backgroundImage' : this.state.musicData.tracks[this.state.activeTrack].cover,\n      }\n      if (this.audios[this.state.activeTrack]) {\n        barWidth = {\n          'width' : parseInt((this.state.currentMusicTime / this.audios[this.state.activeTrack].duration())*100) + \"%\"\n        }\n      }\n    }\n    let renderedPlaylist\n    if (this.state.musicData.tracks) {\n      renderedPlaylist = this.state.musicData.tracks.map( (track, index) =>\n        <div key={index} className=\"playlistElement\">\n          <div className=\"left\">\n            <div className=\"artist\">{track.artistName + \" - \"}</div>\n            <div className=\"title\">{track.title}</div>\n          </div>\n          <div className=\"duration\">{this.audios[index] ? this.formatTime(this.audios[index].duration()) : track.duration}</div>\n          {(index === this.state.activeTrack) ? <div style={barWidth} className=\"timeProgression\"></div> : \"\"}\n        </div>\n      )\n    }\n    \n    return ( \n      <div className=\"container\">\n        <div className=\"background\">\n          <div style = {backgroundImageStyle} className=\"bgImage\"></div>\n          <div className=\"bgFilter\"></div>\n        </div>\n        <div className=\"musicPlayer\">\n          <div id=\"visualizer\"></div>\n          <div className=\"card\">\n              {this.state.activeScreen === \"nowPlaying\" ?\n              <div className=\"flex-wrap\">\n                <div className=\"info\">\n                  <div className=\"artist\">{this.state.musicData ? this.state.musicData.tracks[this.state.activeTrack].artistName : \"artist\"}</div>\n                  <div className=\"album\">{this.state.musicData ? this.state.musicData.tracks[this.state.activeTrack].album : \"album\"}</div>\n                  <div className=\"title\">{this.state.musicData ? this.state.musicData.tracks[this.state.activeTrack].title : \"title\"}</div>\n                </div>\n                <div className=\"controls\">\n                  <div onClick={()=> {this.changeSong(\"previous\")}} className=\"before\">before</div>\n                  <div onClick={this.toggleAudio} className=\"playPause\"> {this.state.fileIsLoaded ? \"play\" : \"loading\"}</div>      \n                  <div onClick={()=> {this.changeSong(\"next\")}} className=\"next\">next</div>\n                </div>\n                <div className=\"progressBar\">\n                  <div className=\"actualTime\">{this.formatTime(this.state.currentMusicTime)}</div>\n                  <div className=\"totalTime\">{\n                  this.state.musicData.tracks && this.audios[this.state.activeTrack] ?  this.formatTime(this.audios[this.state.activeTrack].duration()) : \"00:00\"\n                  }</div>\n                  <div\n                    style={barWidth}\n                    className=\"timeProgression\"\n                  ></div>\n                </div>\n              </div>\n              : renderedPlaylist ?\n                <div className=\"playlist\">{renderedPlaylist}</div>\n               : \"loading\"\n              }\n            <div onClick = {this.playlistSwitch} className=\"playlistSwitch\">{this.state.activeScreen === 'nowPlaying' ? \"PLAYLIST\" : 'PLAYING NOW'}</div>\n            <div className=\"volume\">\n              <div className=\"volumeIcon\">VOL</div>\n              <div className=\"volumeProgression\">\n                <div className=\"volumePercentage\">72%</div>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n     );\n  }\n}\n \nexport default App ;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}